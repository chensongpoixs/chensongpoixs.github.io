---
layout:     post
title:      redis源码分析之sha1算法分析
subtitle:   sha1算法分析与hash表的生成
date:       2019-10-01
times:      21::30::02
author:     chensong
header-img: img/2019-02-02/bg_socketopt.jpg
catalog: 	 true
tags:
    - Redis源码探秘
    - 算法
    - 加密与解密技术核心思想
---



## 前言

在密码学分为三大类分别是

1. 不可逆算法 (md5, sha家族, HmacSHa家族)
2. 可逆的算法 (AES, DES, RC4, Rabbit, TripleDes)
3. 可逆的算法公钥和私钥 (RSA)

我在redis源码中hash表的因子是使用sha1算法生成的。

## 正文

### 1, sha1算法原理分析

了解sha1介绍

SHA-1（英语：Secure Hash Algorithm 
1，中文名：安全散列算法1）是一种密码散列函数，美国国家安全局设计，并由美国国家标准技术研究所（NIST）发布为联邦数据处理标准（FIPS）。SHA-1可以生成一个被称为消息摘要的160位（20字节）散列值，散列值通常的呈现形式为40个十六进制数。


sha1 用于2的64次方的数据进行加密生成 160位的（20字节）散列值。

sha1 是一块一块的加密的每块有512位（64字节）进行加密 

最后使用80个int类型临时数组存放加密的数据


1怎么把我们的数据转换要转换一块一块数据是什么格式呢？

举例: 

对 "abc" 加密 我们要先把abc转换为ASCII码表对应的二进制

```
01100001 01100010 01100011


‘a’=97 ‘b’=98 ‘c’=99
```

字符串的长度就是24（二进制）

 补位：

消息必须进行补位，以使其长度在对512取模以后的余数是448。也就是说，（补位后的消息长度）%512 = 448。即使长度已经满足对512取模后余数是448，补位也必须要进行。
补位是这样进行的：先补一个1，然后再补0，直到长度满足对512取模后余数是448。总而言之，补位是至少补一位，最多补512位。还是以前面的“abc”为例显示补位的过程。
原始信息： 01100001 01100010 01100011
补位第一步：01100001 01100010 01100011 1
首先补一个“1”
补位第二步：01100001 01100010 01100011 10…..0
然后补423个“0”
我们可以把最后补位完成后的数据用16进制写成下面的样子

```
61626380 00000000 00000000 00000000
00000000 00000000 00000000 00000000
00000000 00000000 00000000 00000000
00000000 00000000
```

现在，数据的长度是448了，我们可以进行下一步操作。

补长度

所谓的补长度是将原始数据的长度补到已经进行了补位操作的消息后面。通常用一个64位的数据来表示原始消息的长度。如果消息长度不大于2^64，那么第一个字就是0。在进行了补长度的操作以后，整个消息就变成下面这样了（16进制格式）

```
61626380 00000000 00000000 00000000
00000000 00000000 00000000 00000000
00000000 00000000 00000000 00000000
00000000 00000000 00000000 00000018
```

如果原始的消息长度超过了512，我们需要将它补成512的倍数。然后我们把整个消息分成一个一个512位的数据块，分别处理每一个数据块，从而得到消息摘要。


  使用的常量

一系列的常量字K(0), K(1), ... , K(79)，如果以16进制给出。它们如下：

```
Kt = 0x5A827999 (0 <= t <= 19)
Kt = 0x6ED9EBA1 (20 <= t <= 39)
Kt = 0x8F1BBCDC (40 <= t <= 59)
Kt = 0xCA62C1D6 (60 <= t <= 79).
```

需要使用的函数
	  
在SHA1中我们需要一系列的函数。每个函数ft (0 <= t <= 79)都操作32位字B，C，D并且产生32位字作为输出。ft(B,C,D)可以如下定义

```
ft(B,C,D) = (B AND C) or ((NOT B) AND D) ( 0 <= t <= 19)
ft(B,C,D) = B XOR C XOR D (20 <= t <= 39)
ft(B,C,D) = (B AND C) or (B AND D) or (C AND D) (40 <= t <= 59)
ft(B,C,D) = B XOR C XOR D (60 <= t <= 79).
```

计算消息摘要

必须使用进行了补位和补长度后的消息来计算消息摘要。计算需要两个缓冲区，每个都由5个32位的字组成，还需要一个80个32位字的缓冲区。第一个5个字的缓冲区被标识为A，B，C，D，E。第二个5个字的缓冲区被标识为H0, H1, H2, H3, H4。80个字的缓冲区被标识为W0, W1,..., W79
另外还需要一个一个字的TEMP缓冲区。
为了产生消息摘要，在第4部分中定义的16个字的数据块M1, M2,..., Mn
会依次进行处理，处理每个数据块Mi 包含80个步骤。
在处理每个数据块之前，缓冲区{Hi} 被初始化为下面的值（16进制）

```
H0 = 0x67452301
H1 = 0xEFCDAB89
H2 = 0x98BADCFE
H3 = 0x10325476
H4 = 0xC3D2E1F0.
```

现在开始处理M1, M2, ... , Mn。为了处理 Mi,需要进行下面的步骤

(1). 将 Mi 分成 16 个字 W0, W1, ... , W15, W0 是最左边的字
(2). 对于 t = 16 到 79 令 Wt = S1(Wt-3 XOR Wt-8 XOR Wt- 14 XOR Wt-16).
(3). 令 A = H0, B = H1, C = H2, D = H3, E = H4.
(4) 对于 t = 0 到 79，执行下面的循环

TEMP = S5(A) + ft(B,C,D) + E + Wt + Kt;
E = D; D = C; C = S30(B); B = A; A = TEMP;

(5). 令 H0 = H0 + A, H1 = H1 + B, H2 = H2 + C, H3 = H3 + D, H4 = H4 + E.
在处理完所有的 Mn, 后，消息摘要是一个160位的字符串，以下面的顺序标识
H0 H1 H2 H3 H4.
对于SHA256,SHA384,SHA512。你也可以用相似的办法来计算消息摘要。对消息进行补位的算法完全是一样的。

### 2, sha1算法的实现


```
#include <stdio.h>
#include <stdlib.h>
#include <string.h>



static const int parm[5] = { 
	0x67452301, 
	0xEFCDAB89,
	0x98BADCFE,
	0x10325476,
	0xC3D2E1F0 
};

static int chararraytoint(unsigned char* ptr, unsigned int index)
{
	return ((ptr[index] & 0xff) << 24) | ((ptr[index + 1] & 0xff) << 16) | ((ptr[index + 2] & 0xff) << 8) | (ptr[index + 3] & 0xff);
}

static int s(unsigned int x, unsigned int i)
{
	return (x << i) | x >> (32 - i);
}


static int f1(int x, int y, int z)
{
	return (x&y) | (~x&z);
}
static int f2(int x, int y, int z)
{
	return x^y^z;
}
static int f3(int x, int y, int z)
{
	return (x&y) | (x&z) | (y&z);
}
static int f4(int x, int y, int z)
{
	return x^y^z;
}


unsigned char * get_src_hex(char *p, unsigned int len, unsigned long long *size)
{
	if (!p || len <= 0)
	{
		return NULL;
	}
	unsigned int fill = 0; //填充'0'
	//unsigned long long size = *_size; //数据的大小
	
	unsigned int  m_size = len % 64; //有几个数据块     512位为一块
	if (m_size < 56) //  最后的16位是数据块的长度保存
	{
		fill = 55 - m_size;
		*size = len - m_size + 64; //数据的大小//size = strlen(p) - src_lenght + 64;//data_size的开始位置
	}
	else if (m_size == 56)
	{
		fill = 63;
		*size = len + 8 + 64;
	}
	else
	{
		fill = 63 - m_size + 56;
		*size = (len + 64) - m_size + 64;
	}

	unsigned char * ptr = (unsigned char *)malloc(sizeof(unsigned char) * (*size));
	if (!ptr)
	{
		return NULL;
	}

	memcpy(ptr, p, len);

	// 结束标志位 0x80
	ptr[len] = 0x80;
	// 补'0'操作
	for (int i = 0; i < fill; ++i)
	{
		ptr[len + i + 1] = (unsigned char)0x00;
	}
	//保存到最后的十六位中
	unsigned long long m_hex_size = len * 8;

	//memcpy(ptr[len + 2 + fill ], (unsigned char)m_hex_size, 8);
	ptr[strlen(p) + fill + 1] = (unsigned char)(m_hex_size >> 56);
	ptr[strlen(p) + fill + 2] = (unsigned char)((m_hex_size>> 48) & 0xFF);
	ptr[strlen(p) + fill + 3] = (unsigned char)((m_hex_size>> 40) & 0xFF);
	ptr[strlen(p) + fill + 4] = (unsigned char)((m_hex_size>> 32) & 0xFF);
	ptr[strlen(p) + fill + 5] = (unsigned char)((m_hex_size>> 24) & 0xFF);
	ptr[strlen(p) + fill + 6] = (unsigned char)((m_hex_size>> 16) & 0xFF);
	ptr[strlen(p) + fill + 7] = (unsigned char)((m_hex_size>> 8) & 0xFF);
	ptr[strlen(p) + fill + 8] = (unsigned char)(m_hex_size & 0xFF);


	return ptr;
}



int * get_sha1_update(unsigned char *ptr, unsigned long long size)
{
	if (!ptr || size == 0)
	{
		return NULL;
	}
	//计算有多少块
	int m_count = size / 64;
	int * temp = malloc(sizeof(int) * 80);
	if (!temp)
	{
		return NULL;
	}
	int * tempabcde = malloc(sizeof(int) * 5);
	if (!tempabcde)
	{
		return NULL;
	}
	int * h = malloc(sizeof(int) * 5);
	if (!h)
	{
		return NULL;
	}
	//memcpy(hex_enc, parm, 5);
	for (int i = 0; i < 5; ++i)
	{
		h[i] = parm[i];
	}
	for (int pos = 0; pos < m_count; pos++)
	{
		printf("pos = %d\n", pos);
		for (int i = 0; i < 16; i++)
		{
			temp[i] = chararraytoint(ptr, (pos * 64) + (i * 4));
			printf("[---> temp[%d] = %d]\n", i, temp[i]);
		}

		for (int t = 16; t <= 79; t++)
		{
			temp[t] = s(temp[t - 3] ^ temp[t - 8] ^ temp[t - 14] ^ temp[t - 16], 1);
			printf("m[%d]=%d\n", t, temp[t]);
		}
		for (int i = 0; i < 5; ++i)
		{
			tempabcde[i] = h[i];
		}

		for (int i = 0; i <= 19; i++)
		{
			int temp_1 = s(tempabcde[0], 5)
				+ f1(tempabcde[1], tempabcde[2], tempabcde[3])
				+ tempabcde[4]
				+ temp[i] + 0x5A827999;
			tempabcde[4] = tempabcde[3];
			tempabcde[3] = tempabcde[2];
			tempabcde[2] = s(tempabcde[1], 30);
			tempabcde[1] = tempabcde[0];
			tempabcde[0] = temp_1;
		}
		for (int i = 20; i <= 39; i++)
		{
			int temp_1 = s(tempabcde[0], 5)
				+ f2(tempabcde[1], tempabcde[2], tempabcde[3])
				+ tempabcde[4]
				+ temp[i] + 0x6ED9EBA1;
			tempabcde[4] = tempabcde[3];
			tempabcde[3] = tempabcde[2];
			tempabcde[2] = s(tempabcde[1], 30);
			tempabcde[1] = tempabcde[0];
			tempabcde[0] = temp_1;
		}
		for (int i = 40; i <= 59; i++) {
			int temp_1 = s(tempabcde[0], 5)
				+ f3(tempabcde[1], tempabcde[2], tempabcde[3])
				+ tempabcde[4]
				+ temp[i] + 0x8F1BBCDC;
			tempabcde[4] = tempabcde[3];
			tempabcde[3] = tempabcde[2];
			tempabcde[2] = s(tempabcde[1], 30);
			tempabcde[1] = tempabcde[0];
			tempabcde[0] = temp_1;
		}
		for (int i = 60; i <= 79; i++) {
			int temp_1 = s(tempabcde[0], 5)
				+ f4(tempabcde[1], tempabcde[2], tempabcde[3])
				+ tempabcde[4]
				+ temp[i] + 0xCA62C1D6;
			tempabcde[4] = tempabcde[3];
			tempabcde[3] = tempabcde[2];
			tempabcde[2] = s(tempabcde[1], 30);
			tempabcde[1] = tempabcde[0];
			tempabcde[0] = temp_1;
		}
		//5.令 H0 = H0 + A, H1 = H1 + B, H2 = H2 + C, H3 = H3 + D, H4 = H4 + E.
		for (int i = 0; i < 5; i++)
		{
			h[i] = h[i] + tempabcde[i];
			printf("[h[%d] = %d]\n", i, h[i]);
		}
		//完成了一次操作
		//清除之前的内容，开始下一个块的计算
		for (int i = 0; i < 80; i++)
		{
			temp[i] = 0;
		}
	}
	free(tempabcde);
	free(temp);
	return h;
}
int main(int argc, char *argv[])
{

	char * p = "abc";//616263   a=> 61, b => 62, c => 63
	
	unsigned long long size = 0;
	unsigned char * ptr = get_src_hex(p, strlen(p), &size);
	if (!ptr)
	{
		printf("[errro]\n");
		//system("pause");
		return -1;
	}
	printf("[");
	//61626380000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000018
	for (size_t i = 0; i < size; i++)
	{
		printf("%02x", ptr[i]);// 616263
	}
	printf("]\n");
	printf("strlen(ptr) = %zd\n", strlen(ptr));

	
	printf("----------------\n[");
	unsigned char hash[20];
	int * h = get_sha1_update(ptr, size);
	if (!h)
	{
		printf("[error]\n");
		//system("pause");
		return -1;
	}
	for (int i = 0; i < 5; ++i)
	{
		hash[(i * 4)] =(char)(( h [i]>>  24) & 0xff);
		hash[(i * 4) + 1] = (char)((h[i] >>  16) & 0xff);
		hash[(i * 4) + 2] = (char)((h[i] >>  8) & 0xff);
		hash[(i * 4) + 3] = (char)((h[i] & 0xff));
	}
	//memcpy(hash, h, 20);
	for (int i = 0; i < 20; ++i)
	{
		printf("%02x", hash[i]);// 616263
	}
	printf("]\n");
	//memcpy(ptr + strlen(p), 0x80, 1);
	//memcpy()
	free(h);
	free(ptr);
	
	//system("pause");
	return EXIT_SUCCESS;
}
```

### 3, redis中sha1源码分析



[源码地址](https://github.com/chensongpoixs/calgorithms/blob/master/C++/encrypt/sha1/csha1.c)

## 结语