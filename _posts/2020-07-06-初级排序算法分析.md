---
layout:     post
title:      初级排序算法分析.md
subtitle:   1,选择排序 2, 插入排序 3, 希尔排序 4, 归并排序 5, 快速排序 6, 堆排序
date:       2020-07-06
times:       22::22::24
author:     chensong
header-img: img/2019-01-11/bg_mem_pool.jpg
catalog: 	 true
tags:
    - 算法专题
    - 初级排序算法
---



## 前言



## 正文

### 一, 选择排序

 选择排序是排序中最简单的排序算法,它的操作是这样的: 首先找到数组中最小那个的元素，其次，将它和数组的第一个元素交换位置(如果第一个元素就是最小元素那么它就和自己交换)。再次，剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。如此往复，直到将整个数组排序。它在不断地选择剩余元素之中的最小者。
 
![](https://github.com/chensongpoixs/chensongpoixs.github.io/blob/master/img/2020-07-06/selection_sort.png?raw=true)

命题A: 对于长度为N的数组,选择排序需要大约(N^2)/2次比较和N次交换

证明: 可以通过身份的排序轨迹来证明这一点。我们用一张N*N的表格来表示排序的轨迹(上图)，其中每个非红色的数字都表示一次比较。表中大约一半的元素表示黄色的--即对角线和其上部分的元素。对角线上的每个元素都对应一次交换。看代码我们可以更精准得到，0到N-1的任意i都会进行一次交换和N-1-i次比较，因此总共有N次交换以及（N-1）+（N-2）+（N-3）+...+2+1 = N(N-1)/2 ~(N^2)/2次比较。

总的来说，选择排序是一种很容易理解和实现的简单排序算法，它有两个很鲜明的特点。

运行时间和输入无关。为了找出最小元素二扫描一个数组并不能为下一遍扫描提供扫描信息。这种性质在某些情况下是缺点，因为使用选择排序的人可能会惊讶地发现，一个已经有序的数组或者是主键全部相等的数组和一个元素随机排列的数组所用的排序时间竟然一样长！我们将会看到，其他算法会更善于利用输入的初始状态。


数据移动是最小的，每次交换都会改变两个数组元素的值，因此选择排序用了N次交换---交换次数和数组的大小是线性关系。


```
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
void show(int * array, int len)
{
    for (int i = 0; i < len; ++i)
    {
        printf(" %d , " , array[i]);
    }
    printf("\n");
}


/**
 * 选择排序
 * @param array
 * @param len
 */
void selection(int * array, int len)
{

    for (int i = 0; i < len; ++i)
    {
        //最小元素的下标
        int min_index = i;
        for (int j = i; j < len; ++j)
        {
            if (array[min_index] > array[j])
            {
                min_index = j;
            }
        }
        //交换元素
        int temp = array[i];
        array[i] = array[min_index];
        array[min_index] = temp;
    }
}

int main(int argc, char *argv[])
{

    int array[] = { 78, 23, 56, 12, 1, 100, 23, 11, 9, 2};
    int len = sizeof(array) / sizeof(int);
    show(&array[0], len);
    selection(&array[0], len);
    show(&array[0], len);
	system("pause");
    return 0;
}

```

![](https://github.com/chensongpoixs/chensongpoixs.github.io/blob/master/img/2020-07-06/selection_sort_run.png?raw=true)


### 二,插入排序

通常人们整理牌的方法是一张一张来的，将每一张牌插入到其他已经有序的牌中的适当位置。在计算机的实现中，为了给要插入的元素腾出空间，我们需要将其余所有元素在插入之前都向右移动一位。这种说法叫做插入排序。

与选择排序一样，当前索引左边的所有元素都是有序的，但它们的最终位置还不确定，为了给更小的元素腾出空间,它们可能会被移动。但是当索引到达数组的右端时，数组排序就完成了。

和选择排序不同的是，插入排序所需的时间取决于输入中元素的初始顺序。例如，对一个很大且其中元素已经有序(或接近有序)的数组进行排序将会比对随机顺序的数组或是逆序数组进行排序要快得多。

命题B: 对于随机排列的长度为N且主键不重复的数组，平均情况下插入排序需要(N^2)/4次比较以及N^2/4次交换。最坏情况下需要(N^2)/2次交换，最好情况下需要N-1次比较和0次交换。

证明：和命题A一样，通过一个N*N的轨迹表可以很容易就得到交换和比较的次数。最坏情况下对角线之下所有的元素都需要移动位置，最好情况下都不需要。对于随机排列的数组，在平均情况下每个元素都可能向后移动半个数组的长度，因此交换总数是对角线之下的元素总数的二分之一。

比较的总次数是交换的次数加上一个额外的项，该项为N减去被插入的元素正好是已知的最小元素的次数。在最坏情况下(逆序数组)，这一项相对总数可以忽略不计；在最好情况下(数组已经有序)，这一项等于N-1.

![](https://github.com/chensongpoixs/chensongpoixs.github.io/blob/master/img/2020-07-06/insertion_sort.png?raw=true)


```

/************************************************************************/
/* 插入排序                                                                     */
/************************************************************************/
void insertion(int* array, int len)
{
	for (int i = 0; i < len; ++i)
	{
		//判断j下标前面数据是否小于j-1的元素
		for (int j = i; j > 0 && array[j] < array[j -1]; --j)
		{
			//交换元素
			int temp = array[j];
			array[j] = array[j-1];
			array[j-1] = temp;
		}
	}
}
```





## 结语
