---
layout:     post
title:      Libevent的事件驱动源码分析(二)
subtitle:   多线程支持
date:       2019-07-04
times:      23::22::41
author:     chensong
header-img: img/2019-01-24/bg_io_service.jpg
catalog: 	 true
tags:
    - 多线程
    - 网络编程
    - Libevent源码探秘
---

## 前言

   libevent线程是不安全的, 现在服务器都是多核的如何充分使用cpu就要使用多线程。 
   

## 正文

### 一, 谈谈libevent如何使用多线程呢

我们在上学的时候， 经常去学校的食堂吃饭。 有几种情况

#### 1, 一个窗口排队等待打饭

一个窗口就相当于我们网络中io单线程的处理， 不会出现惊群效应(linux 3.0+ epoll这个问题已经解决了) ,这个效率会比较底下, 学生排队的时间过长

#### 2, 多个窗口排队等待打饭

多个窗口排队等待打饭， 一个窗口就相当于我们一个线程， 处理的速度就会比较快的， 效率较高。

### 二, 谈谈libevent如何多线程中通信的

libevent使用两种方式通信 

1. 管道 (pipe)
2. socket


#### 1，我们一起看看怎么使用socket 通信的


evutil_socketpair 创建socket
事件通知int (*notify)(struct event_base *) = evthread_notify_base_default;         // io 线程的操作回调函数
base->th_notify_fn = notify;

evthread_notify_base_default这个函数就通知事件写入1个字节数据

接收线程 void (*cb)(evutil_socket_t, short, void *) = evthread_notify_drain_default; // main thread 回调函数

放到事件队列中去了

evthread_notify_drain_default函数就修改变量is_notify_pending


#### 2, 唤醒线程的流程

##### ① event_add_internal

```
	if (base->current_event == ev && (ev->ev_events & EV_SIGNAL)
	    && !EVBASE_IN_THREAD(base)) 
	{
		++base->current_event_waiters;
		// 等待 通知工作  
		EVTHREAD_COND_WAIT(base->current_event_cond, base->th_base_lock);
	}
```

##### ② event_del_internal

```
	if (base->current_event == ev && !EVBASE_IN_THREAD(base)) 
	{
		++base->current_event_waiters; // wait
		// 等待 通知工作  
		EVTHREAD_COND_WAIT(base->current_event_cond, base->th_base_lock);
	}
```

##### ③ event_active_nolock

```
	if (base->current_event == ev && !EVBASE_IN_THREAD(base)) 
	{
		++base->current_event_waiters;
		// 等待 通知工作  
		EVTHREAD_COND_WAIT(base->current_event_cond, base->th_base_lock);
	}
```

#### 2. 广播的函数

#####	① event_process_active_single_queue

```
for (ev = TAILQ_FIRST(activeq); ev; ev = TAILQ_FIRST(activeq)) 
{
	if (ev->ev_events & EV_PERSIST)
	{
		event_queue_remove(base, ev, EVLIST_ACTIVE);
	}
	else
	{
		event_del_internal(ev);
	}
	if (!(ev->ev_flags & EVLIST_INTERNAL))
	{
		++count;
	}

	event_debug((
		 "event_process_active: event: %p, %s%scall %p",
		ev,
		ev->ev_res & EV_READ ? "EV_READ " : " ",
		ev->ev_res & EV_WRITE ? "EV_WRITE " : " ",
		ev->ev_callback));

#ifndef _EVENT_DISABLE_THREAD_SUPPORT
	base->current_event = ev;
	base->current_event_waiters = 0;
#endif

	switch (ev->ev_closure) 
	{
	case EV_CLOSURE_SIGNAL:
		event_signal_closure(base, ev);
		break;
	case EV_CLOSURE_PERSIST:
		event_persist_closure(base, ev);
		break;
	default:
	case EV_CLOSURE_NONE:
		EVBASE_RELEASE_LOCK(base, th_base_lock);
		(*ev->ev_callback)(
			(int)ev->ev_fd, ev->ev_res, ev->ev_arg);  //  调用业务的回调函数 
		break;
	}

	EVBASE_ACQUIRE_LOCK(base, th_base_lock);
#ifndef _EVENT_DISABLE_THREAD_SUPPORT
	base->current_event = NULL;
	if (base->current_event_waiters)
	{
		base->current_event_waiters = 0;
		// 通知 广播 main all thread wait事件 起来工作了 ^_^
		EVTHREAD_COND_BROADCAST(base->current_event_cond);
	}
#endif

	if (base->event_break)
	{
		return -1;
	}
}

```



### 三 ， 多线程

上面的等待是否是多线程每个线程独有event_base的都启动一个线程



## 结语




